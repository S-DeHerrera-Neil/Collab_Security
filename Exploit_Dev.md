# Buffer Overflow Terms
| Name | Descrition |
| - | - |
|Heap|Memory that can be allocated and deallocated|
|Stack|A contiguous section of memory used for passing arguments|
|Registers|Storage elements as close as possible to the central processing unit (CPU)|
|Instruction Pointer (IP)|a.k.a Program Counter (PC), contains the address of next instruction to be executed|
|Stack Pointer (SP)|Contains the address of the next available space on the stack|
|Base Pointer (BP)|The base of the stack|
|Function|Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient|
|Shellcode|The code that is executed once an exploit successfully takes advantage of a vulnerability|

# Buffer Overflow Defenses
-Non executable (NX) stack
-Address Space Layout Randomization (ASLR)
- Data Execution Prevention (DEP)
- Stack Canaries
- Position Independent Executable (PIE)

# Peda
Installation:
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```
Common Commands:
```
disass <FUNCTION>   #   Disassemble portion of the program
info <...>  #   Supply info for specific stack areas
x/256c $<REGISTER>  #   Read characters from specific register
break <address>  #   Establish a break point
```
# Exploit Testing
## Step 1. Does it take arguments?
```
./func $(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
```
## Step 2. Bash String Insertion
```
./func <<< $(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
```
The `<<<` is a way of mimicking user input in bash
## Step 3. String Insertion Via Script
You can write a python script that outputs the contents of a buffer:
```
#!/usr/bin/env python
# linbuffer.py
buffer = "A" * 50
print(buffer)
```
then we can send the input to the executable:
```
./func <<< $(./linbuffer.py)
```
Modifying the buffer size can test where a segmentation fault is, in this case a buffer of 75 yields this result:
```
student@lin-ops:~$ ./func <<< $(./linbuffer.py)
Enter a string: 
Segmentation fault (core dumped)
```
This is a result of overflowing the input buffer and overwriting the actual assembly commands
